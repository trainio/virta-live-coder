"""
Auto-generate effects array for GUI from graphics module
Extracts all functions with their parameters and metadata

Usage:
    python generate_effects_array.py > effects_config.py
"""

import inspect
import ast
from pathlib import Path
import sys

sys.path.insert(0, str(Path(__file__).parent))
from graphics import process, draw, generate, blend, analyze


def get_function_params(func):
    """Extract parameter info from function signature"""
    sig = inspect.signature(func)
    params = []
    
    for name, param in sig.parameters.items():
        if name in ('frame', 'frame1', 'frame2', 'history'):
            continue  # Skip frame parameters
        
        # Get default value
        if param.default != inspect.Parameter.empty:
            default = param.default
            
            # Infer type and range
            if isinstance(default, bool):
                param_type = 'bool'
                min_val = None
                max_val = None
            elif isinstance(default, int):
                param_type = 'int'
                min_val, max_val = infer_int_range(name, default)
            elif isinstance(default, float):
                param_type = 'float'
                min_val, max_val = infer_float_range(name, default)
            elif isinstance(default, str):
                param_type = 'str'
                min_val = None
                max_val = None
            elif isinstance(default, tuple):
                param_type = 'color'
                min_val = None
                max_val = None
            elif isinstance(default, list):
                param_type = 'list'
                min_val = None
                max_val = None
            else:
                param_type = 'any'
                min_val = None
                max_val = None
            
            params.append({
                'name': name,
                'default': default,
                'type': param_type,
                'min': min_val,
                'max': max_val
            })
    
    return params


def infer_int_range(name, default):
    """Infer reasonable min/max for integer parameters"""
    ranges = {
        'kernel_size': (1, 51),
        'iterations': (1, 10),
        'threshold': (0, 255),
        'threshold1': (0, 255),
        'threshold2': (0, 255),
        'value': (0, 255),
        'channel': (0, 2),
        'levels': (2, 16),
        'pixel_size': (1, 50),
        'intensity': (1, 100),
        'spacing': (5, 200),
        'thickness': (1, 20),
        'offset': (0, 50),
        'shift': (0, 180),
        'block_size': (3, 51),
        'line_spacing': (1, 20),
        'diameter': (1, 50),
        'size': (5, 200),
        'amount': (0, 255),
        'ksize': (1, 7),
        'dx': (0, 1),
        'dy': (0, 1),
        'c': (0, 20),
        'stripe_height': (1, 200),
        'stripe_width': (1, 200),
        'square_size': (1, 200),
        'radius': (1, 500),
        'count': (1, 20),
    }
    
    # Check for specific names
    for key, (min_val, max_val) in ranges.items():
        if key in name:
            return min_val, max_val
    
    # Check for position/size parameters
    if any(x in name for x in ['x', 'y', 'width', 'height', 'cx', 'cy']):
        return 0, 2000
    
    # Default range
    if default < 10:
        return 0, 20
    elif default < 100:
        return 0, 200
    else:
        return 0, 500


def infer_float_range(name, default):
    """Infer reasonable min/max for float parameters"""
    ranges = {
        'alpha': (0.0, 3.0),
        'sigma': (0.0, 200.0),
        'sigma_s': (1.0, 200.0),
        'sigma_r': (0.0, 1.0),
        'sigma_color': (1.0, 200.0),
        'sigma_space': (1.0, 200.0),
        'intensity': (0.0, 1.0),
        'line_intensity': (0.0, 1.0),
        'corruption': (0.0, 1.0),
        'decay': (0.0, 1.0),
        'shade_factor': (0.0, 1.0),
        'angle': (0.0, 360.0),
        'start_angle': (0.0, 360.0),
        'end_angle': (0.0, 360.0),
        'font_scale': (0.1, 5.0),
    }
    
    for key, (min_val, max_val) in ranges.items():
        if key in name:
            return min_val, max_val
    
    # Check for contrast/brightness
    if 'contrast' in name or 'brightness' in name:
        return 0.0, 3.0
    
    # Default range
    if default < 1.0:
        return 0.0, 1.0
    elif default < 10.0:
        return 0.0, 10.0
    else:
        return 0.0, 200.0


def generate_effects_array():
    """Generate complete effects array"""
    lines = []
    lines.append('"""')
    lines.append('Auto-generated effects configuration')
    lines.append('Generated by generate_effects_array.py')
    lines.append('"""')
    lines.append('')
    lines.append('from src.graphics import process, draw, generate, blend, analyze')
    lines.append('')
    lines.append('')
    lines.append('# Effects array with all functions and their parameters')
    lines.append('EFFECTS = [')
    
    # Process category
    lines.append('    # ========== PROCESS ==========')
    for name in dir(process):
        if name.startswith('_'):
            continue
        func = getattr(process, name)
        if callable(func):
            params = get_function_params(func)
            lines.append(f"    ('{name}', process.{name}, [")
            for p in params:
                if p['min'] is not None and p['max'] is not None:
                    lines.append(f"        {{'name': '{p['name']}', 'default': {repr(p['default'])}, 'min': {p['min']}, 'max': {p['max']}}},")
                else:
                    lines.append(f"        {{'name': '{p['name']}', 'default': {repr(p['default'])}}},")
            lines.append('    ]),')
    
    # Draw category
    lines.append('')
    lines.append('    # ========== DRAW ==========')
    for name in dir(draw):
        if name.startswith('_'):
            continue
        func = getattr(draw, name)
        if callable(func):
            params = get_function_params(func)
            lines.append(f"    ('{name}', draw.{name}, [")
            for p in params:
                if p['min'] is not None and p['max'] is not None:
                    lines.append(f"        {{'name': '{p['name']}', 'default': {repr(p['default'])}, 'min': {p['min']}, 'max': {p['max']}}},")
                else:
                    lines.append(f"        {{'name': '{p['name']}', 'default': {repr(p['default'])}}},")
            lines.append('    ]),')
    
    # Generate category (skip for GUI - needs special handling)
    lines.append('')
    lines.append('    # ========== GENERATE ==========')
    lines.append('    # Note: Generate functions create new frames, not typically used in pipeline')
    
    # Blend category
    lines.append('')
    lines.append('    # ========== BLEND ==========')
    for name in dir(blend):
        if name.startswith('_') or name == 'history_echo':  # Skip complex ones
            continue
        func = getattr(blend, name)
        if callable(func):
            # Skip history functions for now (need special handling)
            if name.startswith('history_'):
                continue
            
            params = get_function_params(func)
            lines.append(f"    ('{name}', blend.{name}, [")
            for p in params:
                if p['min'] is not None and p['max'] is not None:
                    lines.append(f"        {{'name': '{p['name']}', 'default': {repr(p['default'])}, 'min': {p['min']}, 'max': {p['max']}}},")
                else:
                    lines.append(f"        {{'name': '{p['name']}', 'default': {repr(p['default'])}}},")
            lines.append('    ]),')
    
    # Process category
    lines.append('    # ========== ANALYZE ==========')
    for name in dir(analyze):
        if name.startswith('_'):
            continue
        func = getattr(analyze, name)
        if callable(func):
            params = get_function_params(func)
            lines.append(f"    ('{name}', analyze.{name}, [")
            for p in params:
                if p['min'] is not None and p['max'] is not None:
                    lines.append(f"        {{'name': '{p['name']}', 'default': {repr(p['default'])}, 'min': {p['min']}, 'max': {p['max']}}},")
                else:
                    lines.append(f"        {{'name': '{p['name']}', 'default': {repr(p['default'])}}},")
            lines.append('    ]),')

    lines.append(']')
    lines.append('')
    lines.append('')
    lines.append('# Category mapping')
    lines.append('CATEGORIES = {')
    
    # Generate category map
    for category_name, category_obj in [('process', process), ('draw', draw), ('blend', blend), ('analyze', analyze)]:
        names = [name for name in dir(category_obj) 
                if not name.startswith('_') and callable(getattr(category_obj, name))]
        if category_name == 'blend':
            names = [n for n in names if not n.startswith('history_')]
        lines.append(f"    '{category_name}': {names},")
    
    lines.append('}')
    
    return '\n'.join(lines)


if __name__ == "__main__":
    print(generate_effects_array())